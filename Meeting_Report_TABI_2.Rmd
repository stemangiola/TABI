---
title: "TABI Report"
author: "Isobel Beasley"
date: "Updated 15/02/2020"
output:
  pdf_document:
    number_sections: no
    toc: yes
    toc_depth: 3
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
geometry: left = 1.5cm, right = 1.5cm, top=1.3cm, bottom=1.3cm
header-includes:
- \setlength{\headheight}{12pt}
- \setlength{\footskip}{15pt}
editor_options:
  chunk_output_type: console
classoption: man, noextraspace
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=FALSE, fig.height=8, fig.width = 10, warning=FALSE, message=FALSE, eval = TRUE, fig.show=TRUE, dpi = 2000, fig.align='center', out.width = '100%')
inline_hook <- function(x) {
  if (is.numeric(x)) {
    format(x, digits = 2)
  } else x
}
knitr::knit_hooks$set(inline = inline_hook)
```

```{r packages, include=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)
library(latex2exp)
library(kableExtra)
run_2_plots<-readRDS("~/TABI_specfic_sig.rds")
```

```{r data loading, include=FALSE}

fit_table_purity_complete<-readRDS("~/fit_table_purity_complete.rds")

normalised_PC_TCGA <-readRDS("~/compress_normalised_narm_TCGA.rds")

log_fold_gene_change_sig<-readRDS("~/log_fold_gene_change_sig.rds")

normalised_outlier<-readRDS("~/outlier_table_complete.rds")

run_2_plots<-readRDS("~/TABI_specfic_sig.rds")

run_2_fit<-run_2_plots[[1]]

run_2_fit<- run_2_fit %>% rename(mean_value = mean)

fit_table_purity_complete<- fit_table_purity_complete %>% rename(mean_value = mean)

plot_ed_with_line <- function(gene_name, data, fit_table) {
  
  #Required packages / functions 
  require(ggplot2)
  require(plotly)
  #Requires scale_design and parse_formula from TABI to create scaled design matrix 
  
  #Select only paramters for specified gene
  Gene_table <- fit_table %>% 
    filter(Gene_name == gene_name)
  
  plot_line <- function(x) {
    
    eta <- as.numeric(Gene_table %>%
                        filter(parameters == "inflection[1]") %>% 
                        select(mean_value))
    
    
    beta <- as.numeric(Gene_table %>%
                         filter(parameters == "beta[2,1]") %>%
                         select(mean_value))
    
    y_0 <- as.numeric(Gene_table %>%
                        filter(parameters == "y_cross[1]") %>%
                        select(mean_value))
    
    A<- as.numeric(Gene_table %>%
                     filter(parameters == "A[1]") %>%
                     select(mean_value))
    
    top<-(y_0-A)*(1+exp(eta*beta))
    
    bottom<-(1+exp(-x*beta+eta*beta))
    
    return(log10(exp(A+(top/bottom))+1))}
  
  parse_formula <- function(fm) {
    if(attr(terms(fm), "response") == 1) stop("The formula must be of the kind \"~ covariates\" ")
    else as.character(attr(terms(fm), "variables"))[-1]
  }
  
  scale_design = function(df, formula){
    df %>%
      setNames(c("sample_idx", "(Intercept)", parse_formula(formula))) %>%
      gather(cov, value, -sample_idx) %>%
      group_by(cov) %>%
      mutate( value = ifelse( !grepl("Intercept", cov) & length(union(c(0,1), value)) != 2, scale(value), value )) %>%
      ungroup() %>%
      spread(cov, value) %>%
      arrange(as.integer(sample_idx)) %>%
      select(`(Intercept)`, one_of(parse_formula(formula)))
  }
  
  
  #Create table with scaled CAPRA_S and normalised gene count for graphing
  graphing_table <- data.frame( #Scale CAPRA_S using TABI method 
    CAPRA_S = as.vector(model.matrix(object = ~CAPRA_S, data = data %>% filter(is.na(CAPRA_S)==F, is.na(transcript)==F) %>% filter(transcript ==gene_name)) %>%
                          as_tibble(rownames="sample_idx") %>%
                          scale_design(~CAPRA_S) %>% select(CAPRA_S)),
    #Combine with read counts 
    read_count_normalised = as.vector(data %>% filter(is.na(CAPRA_S)==F) %>% filter(transcript ==gene_name) %>% select(`read_count normalised`)) )
  
  #Plot curve of specified parameters and of count points
  graphing_table %>% 
    ggplot(aes(x=CAPRA_S, y=read_count.normalised)) + 
    geom_point(col="dodgerblue") +
    stat_function(fun=plot_line, geom="line") +
    scale_y_log10() +
    labs(title=paste("Read count vs CAPRA-S for", gene_name), #Label what gene chosen
         x="Scaled CAPRA-S score",
         y="Normalised Read Count + 1") 
  

}

plot_ed_with_linear_group <- function(gene_name, data, fit_table) {
  
  #Required packages / functions 
  require(ggplot2)
  require(plotly)
  #Requires scale_design and parse_formula from TABI to create scaled design matrix 
  
  #Select only paramters for specified gene
  Gene_table <- fit_table %>% 
    filter(Gene_name == gene_name)
  
  plot_line <- function(x) {
    
    eta <- as.numeric(Gene_table %>%
                        filter(parameters == "inflection[1]") %>% 
                        select(mean_value))
    
    
    beta <- as.numeric(Gene_table %>%
                         filter(parameters == "beta[2,1]") %>%
                         select(mean_value))
    
    y_0 <- as.numeric(Gene_table %>%
                        filter(parameters == "y_cross[1]") %>%
                        select(mean_value))
    
    A<- as.numeric(Gene_table %>%
                     filter(parameters == "A[1]") %>%
                     select(mean_value))
    
    top<-(y_0-A)*(1+exp(eta*beta))
    
    bottom<-(1+exp(-x*beta+eta*beta))
    
    return(log10(exp(A+(top/bottom))+1))}
  
  parse_formula <- function(fm) {
    if(attr(terms(fm), "response") == 1) stop("The formula must be of the kind \"~ covariates\" ")
    else as.character(attr(terms(fm), "variables"))[-1]
  }
  
  scale_design = function(df, formula){
    df %>%
      setNames(c("sample_idx", "(Intercept)", parse_formula(formula))) %>%
      gather(cov, value, -sample_idx) %>%
      group_by(cov) %>%
      mutate( value = ifelse( !grepl("Intercept", cov) & length(union(c(0,1), value)) != 2, scale(value), value )) %>%
      ungroup() %>%
      spread(cov, value) %>%
      arrange(as.integer(sample_idx)) %>%
      select(`(Intercept)`, one_of(parse_formula(formula)))
  }
  
  
  #Create table with scaled CAPRA_S and normalised gene count for graphing
  graphing_table <- data.frame( #Scale CAPRA_S using TABI method 
    CAPRA_S = as.vector(model.matrix(object = ~CAPRA_S, data = data %>% filter(is.na(CAPRA_S)==F, is.na(transcript)==F) %>% filter(transcript ==gene_name)) %>%
                          as_tibble(rownames="sample_idx") %>%
                          scale_design(~CAPRA_S) %>% select(CAPRA_S)),
    #Combine with read counts 
    read_count_normalised = as.vector(data %>% filter(is.na(CAPRA_S)==F) %>% filter(transcript ==gene_name) %>% select(`read_count normalised`)) )
  
  #Plot curve of specified parameters and of count points
  graphing_table %>% 
    mutate(Group = ifelse(CAPRA_S<0, 0, 1)) %>%
    ggplot(aes(x=Group, y=read_count.normalised)) + 
    geom_point(col="dodgerblue") +
    stat_smooth(se = FALSE, method = 'lm', col="black") +
    scale_y_log10() +
    labs(title=paste("Read count vs CAPRA-S for", gene_name), #Label what gene chosen
         x="Scaled CAPRA-S score",
         y="Normalised Read Count + 1") 
  
}

plot_ed_with_linear <- function(gene_name, data, fit_table) {
  
  #Required packages / functions 
  require(ggplot2)
  require(plotly)
  #Requires scale_design and parse_formula from TABI to create scaled design matrix 
  
  #Select only paramters for specified gene
  Gene_table <- fit_table %>% 
    filter(Gene_name == gene_name)
  
  plot_line <- function(x) {
    
    eta <- as.numeric(Gene_table %>%
                        filter(parameters == "inflection[1]") %>% 
                        select(mean_value))
    
    
    beta <- as.numeric(Gene_table %>%
                         filter(parameters == "beta[2,1]") %>%
                         select(mean_value))
    
    y_0 <- as.numeric(Gene_table %>%
                        filter(parameters == "y_cross[1]") %>%
                        select(mean_value))
    
    A<- as.numeric(Gene_table %>%
                     filter(parameters == "A[1]") %>%
                     select(mean_value))
    
    top<-(y_0-A)*(1+exp(eta*beta))
    
    bottom<-(1+exp(-x*beta+eta*beta))
    
    return(log10(exp(A+(top/bottom))+1))}
  
  parse_formula <- function(fm) {
    if(attr(terms(fm), "response") == 1) stop("The formula must be of the kind \"~ covariates\" ")
    else as.character(attr(terms(fm), "variables"))[-1]
  }
  
  scale_design = function(df, formula){
    df %>%
      setNames(c("sample_idx", "(Intercept)", parse_formula(formula))) %>%
      gather(cov, value, -sample_idx) %>%
      group_by(cov) %>%
      mutate( value = ifelse( !grepl("Intercept", cov) & length(union(c(0,1), value)) != 2, scale(value), value )) %>%
      ungroup() %>%
      spread(cov, value) %>%
      arrange(as.integer(sample_idx)) %>%
      select(`(Intercept)`, one_of(parse_formula(formula)))
  }
  
  
  #Create table with scaled CAPRA_S and normalised gene count for graphing
  graphing_table <- data.frame( #Scale CAPRA_S using TABI method 
    CAPRA_S = as.vector(model.matrix(object = ~CAPRA_S, data = data %>% filter(is.na(CAPRA_S)==F, is.na(transcript)==F) %>% filter(transcript ==gene_name)) %>%
                          as_tibble(rownames="sample_idx") %>%
                          scale_design(~CAPRA_S) %>% select(CAPRA_S)),
    #Combine with read counts 
    read_count_normalised = as.vector(data %>% filter(is.na(CAPRA_S)==F) %>% filter(transcript ==gene_name) %>% select(`read_count normalised`)) )
  
  #Plot curve of specified parameters and of count points
  graphing_table %>% 
    #mutate(Group = ifelse(CAPRA_S<0, 0, 1)) %>%
    ggplot(aes(x=CAPRA_S, y=read_count.normalised)) + 
    geom_point(col="dodgerblue") +
    stat_smooth(se = FALSE, method = 'lm', col="black") +
    scale_y_log10() +
    labs(title=paste("Read count vs CAPRA-S for", gene_name), #Label what gene chosen
         x="Scaled CAPRA-S score",
         y="Normalised Read Count + 1") 
  
}
```

# (1) Rationale: 
Presently, when approaching the analysis of diferential gene expression from RNA seq data in Prostate Cancer tumours, samples are split into two arbitrary groups; low and high risk of recurrence. A linear equation is then fitted to the read counts and used to distinguish between genes that increase, decrease or have a constant level of transcription throughout the progression of the disease. Whilst this approach is quite simple to both understand and apply, it results in the loss of a considerable amount of information through compressing several risk scores into just two groups. 

In order to increase the amount of information able to be extracted from TCGA data on Prostate Cancer (and potentially other cancers), our aim was to develop and improve a Bayesian inference model for differential gene transcript abundance on continuous covariates (TABI). This model would utilise the pseudo-continuous nature of CAPRA-S (Cancer of the Prostate Risk Assessment Postsurgical; a risk of recurrence score from 0 to 7, where 0 is benign tissue) in order to calculate more precise stages of disease progression for which gene expression change occurs. This in turn would enable the creation of a more accurate picture of the transcriptomic tumour microenvironment at different stages of the disease than has previously been possible. 

Furthermore such a model may be more representiative of the underlying biology as gene transcription often has lower and upper limits as a result of biological requirements and constaints, which liner equation is unable to represent (for e.g. there may be a basal level of gene transcription of an essential gene product required for a cell to survive, or an upper limit where too much of a gene product becomes toxic or where there is insufficent enzymatic activity to further catalyse gene transcription). Hence, our approach may capture more information about the causitive biological processes involved in disease progression than current practices. 

# (2) Methodology:
Raw transcript abundance from the TCGA data set on Prostate Cancer was normalised using the TMM algorithm (through tidyTranscriptomics package ttBulk, GitHub: stemangiola/ttBulk@dev). The effect of known and and unknown confounding factors were considered and resulted in the incorporation of purity score as an secondary continuous covariate in the running of the model. The model itself was encoded in the probabilistic programming language Stan, with the dataset partitioned and run in blocks of 5000 genes.

The model assumes that the normalised gene read counts follow a negative binomial distribution (defined by mean and overdispersion parameters). The log of the expected value normalised gene read ($\log(\hat{Y})$) was fitted to a reparametrised sigmoidal curve; 
$$ (1) \; \, GLA(X,y_0, \beta, \eta, A) = A+\frac{(y_0 -A)(1+e^{\eta \beta_1 })}{(1+e^{\eta \beta_1 -X \beta })} $$In this equation; $X$ is the design matrix containing scaled CAPRA-S risk scores and purity scores, $y_0$ is the log of the expected read count at the middle CAPRA-S risk score, $\beta$ is the matrix of slopes (such that $\beta_1$ refers to the slope corresponding to the main factor of interest, in our case CAPRA-S),
$\eta$ refers to the x coordinate of the highest rate of change in the equation (i.e. the x coordinate of the halfway point between the upper and lower plateaus) which is used to infer the stage at which gene expression changes, and $A$ is a vertical translation parameter which alters the height of either the lower or upper plateau (depending on whether the slope is negative or positive). This equation is able to model a variety of gene expression trends with respect to CAPRA-S score including; constitutive, linear increase or decrease,  exponential increase or decrease, increase or decrease leading to or from plateau, and two plateaus with an intermediate rising or falling phase (demonstrated in plots below).

```{r sigmodial graphs, echo=FALSE}
# $ A+\frac{(y_0 -A)(1+e^{\beta_1 \eta})} {(1+e^{\eta \beta_1 -X \beta })} $
#Plotting function 

#(latex2exp::TeX("Values of equation are; $\\eta =$")
 
 #is.expression(as.expression(5))

plot<-function(eta, beta, y_0, A) {

  #part_1<-plotly::TeX("\\eta")
  #part_1
  #cap<-expression(latex2exp::TeX("Values of equation are; $\\eta =$"), paste(eta), 
             #latex2exp::TeX(", $\\beta =$"), paste(beta), 
             #latex2exp::TeX(", $y_{0}$"), paste(y_0), 
             #latex2exp::TeX(", $A =$ "), paste(A))
  
  #cap<-paste((latex2exp::TeX("Values of equation are; $\\eta =$")), as.expression(paste(eta)))
  
cap=(paste("Values of equation are; $\\eta =$", eta, ", $\\beta =$", beta, ", $y_{0} =$", y_0, ", $A =$ ", A))

plot_line <- function(x) {
    
    top<-(y_0-A)*(1+exp(eta*beta))
    
    bottom<-(1+exp(-x*beta+eta*beta))
    
    return((A+(top/bottom)))}

ggplot(data.frame(x=c(-2,2)), aes(x=x)) + 
 stat_function(fun=plot_line, geom="line")	+ 
labs(x="Normalised Risk Score", y="Log Normalised Gene Count", caption = latex2exp::TeX(cap))
}

p1<-plot(0, 0, 6,6) #Constant
p2<-plot(0,-0.5, 6.5, 17.5) #Linear increase 
p3<-plot(0,0.4,5,8.5) #Linear Decrease 
p5<-plot(2,-2, 15, 0.6) #Exp Decrease
p4<-plot(4.5,1, 5, 3) #Exp Increase
p6<-plot(0,2,4.5,8.5) #sig dec

grid.arrange(grobs = list(p1, p2, p3, p4, p5, p6), ncol=2, top="Fig 1. Range of trends able to be modelled by reparametrised sigmoidal curve")
#Plot Constant, Plot exp increase / decrease
#Linear increase / decrease, increase / decrease leading two or from plateua
#Two plateau with intermediate phase rising  / lowering phase

```
In comparison to previous versions of the model, parameter $A$ was introduced to better model situations where gene expression has a non-zero basal level (without $A$ the lower plateau is by definition $0$). Additionally, after the incorporation of $A$ into the model  $y_0$ was restricted by introducing the parameter $y_{0_{raw}}$ such that; $$ (2) \; \,y_0 = y_{0_{raw}} + A \; \;(y_{0_{raw}}\geq 0)$$ in order to prevent problems with instances of multiple solutions. A linear relationship was fitted between $log(\hat{Y})$ and $\phi$ (log of the reciprocal of overdispersion) over all genes such that the slope coefficient obtained  ($-0.3186$) was input into the model so the gene specific value of $\phi$ was defined to be $$ (3) \; \,\phi = -0.3186\cdot log(\hat{Y}) + \sigma$$ (where $\sigma$ was added to account for variation between genes in this relationship). 
The statistical model is hence defined by the above equations and the following (where $Y$ refers to the normalised read count, and $\hat{Y}$} is the expected normalised transcript abundance); 

$$ (4) \; \, Y_{t,g}\sim NB(\hat{Y_{t,g}}, \frac{1}{e^{\phi}}) $$
$$(5) \; \,\eta \sim N(0,1) $$
$$ (6) \; \,y_{0_{raw}} \sim N(0,1) $$
$$ (7) \; \,A \sim N(0, 2) $$
$$ (8) \; \,\sigma \sim N(0,1) $$
$$ (9) \; \,\beta_r \sim N(0,1) $$
Furthermore, before fitting this equation to the sigmoidal equation, the covariate data (in our case CAPRA-S and purity score) were both scaled to have a mean of 0 and a standard deviation of 1 (this step was performed by TABI). Henceforth, any discussion of the value of $\eta$ (which may be considered the CAPRA-S value at which the largest difference in gene transcription between CAPRA-S scores occurs) is in reference to its scaled value (as this is what the model uses to make predictions) and not its raw unscaled value. 

# (3) Summary Statistics: 
```{r summary_stats, include=FALSE}
no_sig_genes<-as.numeric((fit_table_purity_complete %>% 
  filter(parameters == "beta[2,1]") %>% 
  filter(`2.5%`<0&`97.5%`<0|`2.5%`>0&`97.5%`>0) %>%
  select(Gene_name) %>% 
  distinct() %>%
  summarise(n = n()))$n)

no_genes_test=as.numeric((fit_table_purity_complete %>% 
  select(Gene_name) %>% 
  distinct() %>%
  summarise(n = n()))$n)

total_gene_no<-as.numeric(length(levels(normalised_PC_TCGA$transcript)))

good_rhat<-nrow(fit_table_purity_complete %>%
  filter(Rhat<=1.1))

all_rhat<-nrow(fit_table_purity_complete)
# Add avaerage effect sample size
avg_sample<-mean(fit_table_purity_complete$n_eff, na.rm=T)

```

Any genes with more than one non-zero normalised read count were passed to TABI ($n =$ `r no_genes_test` of a total `r total_gene_no` measured in the TCGA data set). An initial run of 500 iterations (250 warm-up, 250 sampling) resulted in `r no_sig_genes` genes (`r round(100*no_sig_genes/total_gene_no, digits=3)` % of all genes) being assigned as having a statistically significant slope coefficient with respect to CAPRA-S (proxy for differential gene expression through the progression of the disease). Of all analysed parameters (total $n =$ `r all_rhat`) the majority ($n =$ `r good_rhat`) had an $$ Rhat\leq 1.1 $$ indicating that in most cases chains had mixed well in the analysis and effective sample sizes were sufficient (average effective sample size $n =$ `r round(avg_sample, digits=4)`). Once this first passage was complete, generated quantities for $Y$ (with $95%$ width intervals) were used to identify and remove outliers for a second pass. A larger number of iterations were utilised in the second passage (5000, 2500 warm-up, 2500 sampling) in order to better define $95\% $ credible intervals for our parameters. (***Add when second run is complete)

## Distribution of Calculated Parameter Values

```{r posterior plots, echo=FALSE, fig.height=14, fig.width = 10}
p1<-fit_table_purity_complete %>% 
filter(parameters=="inflection[1]") %>%
  ggplot() +
  geom_histogram(aes(x=mean_value)) +
  labs(title=latex2exp::TeX("Distribution of Calculated Inflection Mean Value ($\\bar{\\eta}$)"), 
       x="Calculated Inflection Mean Values")


p2<-fit_table_purity_complete %>% 
filter(parameters=="inflection[1]") %>%
  ggplot() +
  geom_histogram(aes(x=sd)) +
  labs(title="Distribution of Calculated Inflection Standard Deviation", 
       x="Calculated Inflection Standard Deviation")


p3<-fit_table_purity_complete %>% 
filter(parameters=="beta[2,1]") %>%
  ggplot() +
  geom_histogram(aes(x=mean_value)) +
  labs(title=latex2exp::TeX("Distribution of Calculated Slope mean ($\\bar{\\beta}$)"), 
       x="Calculated Slope Mean")

p4<-fit_table_purity_complete %>% 
filter(parameters=="beta[2,1]") %>%
  ggplot() +
  geom_histogram(aes(x=sd)) +
  labs(title="Distribution of Calculated Slope Standard Deviation", 
       x="Calculated Slope Standard Deviation")

p5<-fit_table_purity_complete %>% 
filter(parameters=="A[1]") %>%
  ggplot() +
  geom_histogram(aes(x=mean_value)) +
  labs(title=latex2exp::TeX("Distribution of Calculated Mean Value for A ($\\bar{A}$)"), 
       x="Calculated mean value for A")

p6<-fit_table_purity_complete %>% 
filter(parameters=="A[1]") %>%
  ggplot() +
  geom_histogram(aes(x=sd)) +
  labs(title="Distribution of Calculated Standard Deviation for A", 
       x="Calculated Standard Deviation for A")

p7<-fit_table_purity_complete %>% 
filter(parameters=="y_cross_raw[1]") %>%
  ggplot() +
  geom_histogram(aes(x=mean_value)) +
  labs(title=latex2exp::TeX("Distribution of Calculated Mean Value for $y_{0_{raw}}$  ($\\bar{y_{0_{raw}}$)"), 
       x=latex2exp::TeX("Calculated Mean Value for $y_{0_{raw}$"))

p8<-fit_table_purity_complete %>% 
filter(parameters=="y_cross_raw[1]") %>%
  ggplot() +
  geom_histogram(aes(x=sd)) +
  labs(title=latex2exp::TeX("Distribution of Calculated Standard Deviation for $y_{0_{raw}$"), 
       x=latex2exp::TeX("Calculated Standard Deviation for $y_{0_{raw}$"))

#Due to restriction on y_cross raw such that it must be >0 
grid.arrange(grobs = list(p1, p2, p3, p4, p5, p6, p7, p8), ncol=2, top="Fig 2. Distribution of calculated mean and standard deviation of model parameters")

```

**Add


## Relationship between calculated parameters and log fold gene change

```{r, echo=FALSE, fig.height=10, fig.width = 10}

non_zero_slope_genes<- fit_table_purity_complete %>% 
  filter(parameters == "beta[2,1]") %>% 
  filter(`2.5%`<0&`97.5%`<0|`2.5%`>0&`97.5%`>0) %>% #Selecting either all > 0 for 95% interval / or all < 0
  select(Gene_name) #Which genes

log_early<-log_fold_gene_change_sig %>%
  filter(CAPRA_S<2*-1) %>%
  select(log_sigmoid, gene_name) %>%
  distinct() %>%
  rename(log_early = log_sigmoid)

log_late<-log_fold_gene_change_sig %>%
  filter(CAPRA_S>1) %>%
  select(log_sigmoid, gene_name) %>%
  distinct() %>%
  rename(log_late = log_sigmoid)

log_change<-inner_join(log_early, log_late) %>% mutate(log_fold_change = log_late - log_early)
fit_table_purity_complete_sig <-inner_join(non_zero_slope_genes, fit_table_purity_complete)
p1<-left_join(fit_table_purity_complete_sig, #Combine fit data with log fold gene change data
          log_change %>% 
            rename(Gene_name = gene_name) %>% #Rename to combine by Gene_name
            select(log_fold_change, Gene_name)) %>% 
  distinct() %>%
  filter(parameters == "beta[2,1]") %>% 
  select(parameters, "mean_value", Gene_name, log_fold_change) %>%
  filter(!Gene_name == "TUBBP10") %>% #Two different val / causing problems with pivot wider
  ggplot(aes(x=mean_value, y= log_fold_change, Gene = Gene_name)) +
  geom_point(alpha = 1, col="dodgerblue") +
  labs(title="Log fold Gene Change vs Calculated Slope Mean", x="Calculated Slope mean", y="Calculated Log fold gene expression change") 

p2<-left_join(fit_table_purity_complete_sig, #Combine fit data with log fold gene change data
          log_change %>% 
            rename(Gene_name = gene_name) %>% #Rename to combine by Gene_name
            select(log_fold_change, Gene_name)) %>% 
  distinct() %>%
  filter(parameters == "inflection[1]") %>% 
  select(parameters, "mean_value", Gene_name, log_fold_change) %>%
  filter(!Gene_name == "TUBBP10") %>% #Two different val / causing problems with pivot wider
  ggplot(aes(x=mean_value, y= log_fold_change, Gene = Gene_name)) +
  geom_point(alpha = 1, col="dodgerblue") +
  labs(title = "Log fold gene change vs inflection mean", x="Calculated Inflection mean",  y="Calculated Log fold gene expression change")

grid.arrange(p1, p2, ncol=1,  bottom = "Log fold gene expression change calculated as the log of the expected value of read count at a CAPRA-S score of 7 (estimated using mean parameter estimates with  \n modeled sigmoidal equation) minus the same calculation at a CAPRA-S score of 0")

```


The above graph shows that whilst the sign of the slope and the direction of gene change is consistent (as we would expect) there is not a precise relationship between log fold gene change and slope. This is because parameters $A$ and $y_0$ impact the calculated upper and lower plateaus, which potentially impact the initial value or final value of the equation and hence - log fold gene change. **Add

# (4) Results / Plots:

```{r inflection_mean_plots, echo=FALSE}

non_zero_slope_genes<- fit_table_purity_complete %>% 
  filter(parameters == "beta[2,1]") %>% 
  filter(`2.5%`<0&`97.5%`<0|`2.5%`>0&`97.5%`>0) %>% #Selecting either all > 0 for 95% interval / or all < 0
  select(Gene_name) #Which genes


fit_table_purity_complete_sig <-inner_join(non_zero_slope_genes, fit_table_purity_complete)

fit_table_purity_complete %>% #Data Table of sig fit data
  mutate(Slope_significance = ifelse(`2.5%`<0&`97.5%`<0|`2.5%`>0&`97.5%`>0, "Significant (n=3695)", "Non-Significant (n=31167)")) %>% 
  filter(parameters == "beta[2,1]"|parameters == "inflection[1]") %>% #Select required parameters
  select(parameters, mean_value, Gene_name, Slope_significance) %>%
  filter(!Gene_name == "TUBBP10") %>% #Two different val for TUBP10 / possible dup?
  pivot_wider(names_from = parameters, values_from = mean_value) %>% #Reshape table for plotting
  rename(Inflection_mean="inflection[1]", Slope_mean ="beta[2,1]")%>% 
  ggplot(aes(x=Inflection_mean, y= Slope_mean, color=Slope_significance)) +
  geom_point(alpha=0.7) + 
  scale_color_manual(name = "", values = c("Significant (n=3695)" = "dodgerblue","Non-Significant (n=31167)"= "black")) +
  geom_point(col="black", alpha=0.7) + 
  geom_point(aes(x=Inflection_mean, y= Slope_mean), alpha=0.7, col="dodgerblue", data = fit_table_purity_complete_sig %>% #Data Table of sig fit data
  filter(parameters == "beta[2,1]"|parameters == "inflection[1]") %>% #Select required parameters
  select(parameters, mean_value, Gene_name) %>%
  filter(!Gene_name == "TUBBP10") %>% #Two different val for TUBP10 / possible dup?
  pivot_wider(names_from = parameters, values_from = mean_value) %>% #Reshape table for plotting
  rename(Inflection_mean="inflection[1]", Slope_mean ="beta[2,1]")) +
  stat_smooth(se = FALSE, method = 'lm', col="red") + #Plot fitted linear eq
  labs(title = "Fig 2. TABI Calculated Slope mean vs Inflection mean",
       y="Calculated Slope Mean", 
       x="Calculated Inflection Mean",
       caption ="Each point represents a single gene analysed by TABI (n = 34862)") +
  theme(text = element_text(size=10), legend.position="bottom")


#Plotting slope against inflection value
load(file="~/slope_table.rda")
load(file="~/inflection.rda")

#Plot slope statistics means against their retrospective inflection values
cbind(slope_table, Inflection) %>% 
  ggplot(aes(x=Inflection, y=`mean`)) +
  geom_point(col="dodgerblue") +
  stat_smooth(se = FALSE, method = 'lm', col="red") +
  #ylim(-3,3) +
  labs(title="TABI Calculated Slope mean vs Inputted Inflection",
       caption="(n=100 simulated inflections, no data input)",
       x="Simulated Inflection Values",
       y="Calculated Mean Slope Values") + 
  ylim(-3,3) +
  theme(text = element_text(size=10))
  
```
In general there is a negative trend between the calculated slope mean and inflection mean (i.e. genes which change expression levels late in disease progression tend to be those which decrease in gene expression over disease progression). Potential outliers (genes with large absolute values of mean slope, in the top right hand corner of the graph and the bottom left hand corner of the graph) may be skewing the plotting of a linear relationship between mean slope and inflection, hence the true trend may be larger and stronger than that calculated above. 

```{r, echo=FALSE}
fit_table_purity_complete_sig %>% 
  filter(parameters =="inflection[1]") %>%
  ggplot(aes(y=mean_value, x=sd, Gene=Gene_name)) +
  geom_point(alpha=0.5, col="dodgerblue") +
  labs(x="Calculated Inflection Standard Deviation",
       y="Calculated Inflection Mean Value",
       title="Calculated Inflection Mean Value vs Standard Deviation",
       subtitle ="(n=34862)",
       caption = "Red = localised inflection threshold (0.7375), \n Black = wide inflection threshold (0.9749), \n Blue = late/early change threshold (0)") +
  geom_vline(xintercept=0.7375, colour ="red") +
  geom_vline(xintercept=0.9749, colour="black") +
  geom_hline(yintercept=0, colour = "darkblue") +
  theme(text = element_text(size=20))


```

As can be seen in the above plot, the mean and standard deviation of inflection cluster around zero and one respectively (may be a reflection of our prior on inflection of N(0,1). Low standard deviation for inflection is a indication of a sharper inflection (a gene with a more sigmoidal trend), so points towards the left of the plot are good candidates for sigmoidal trends. From this point on, localised inflection refers to genes with an inflection sd in the first quartile (i.e. <0.7375, generally genes with more sigmodial like trends) and wide inflection refers to genes with an inflection sd in the fourth quantile (i.e. >0.9749, generally genes with more linear like trends). 

# (5) Examples of Trends Detected 
## Examples of Genes with Localised Inflections (i.e. Sigmoidal-like Trends) *(Calculated Inflection standard deviation <0.7375, in the first quartile)*
```{r, include=FALSE, eval=FALSE, fig.height=8, fig.width = 15}

p11<-plot_ed_with_linear_group("C12orf49", normalised_outlier, fit_table_purity_complete_sig) +
  theme(text = element_text(size=20))

p12<-plot_ed_with_linear("C12orf49", normalised_outlier, fit_table_purity_complete_sig) +
  theme(text = element_text(size=20))

p13<-plot_ed_with_line("C12orf49", normalised_outlier, fit_table_purity_complete_sig)  +
  theme(text = element_text(size=20))

grid.arrange(p11, p12, p13, ncol=3)
```

```{r, echo=FALSE, fig.height=12, fig.width = 10}
load("~/TABI_sig_1.rda")
run_3_fit<- TABI_sig_1[[1]] %>% rename(mean_value = mean)

#plot_ed_with_line("ACP7", normalised_outlier, run_3_fit) nice middle decrease

#run_3_fit %>% filter(Gene_name=="ACP7")

#Add Make such that all information is able to be seen
#Plot normalised read conts on log scale, against scaled CAPRA_S
#Overlay TABI sigmoid equation (using mean values for each parameter value in the equation)
#Details of plotting function in appendix

#plot_ed_with_line("PTEN", normalised_outlier, fit_table_purity_complete_sig) #Late Decrease

p1<-plot_ed_with_line("C12orf49", normalised_outlier, fit_table_purity_complete_sig)  + labs(subtitle="Early Increase")



#Problem Curves? curves seem at least exg. compared to results 

#plot_ed_with_line("IGLL1", normalised_outlier, fit_table_purity_complete_sig)


#plot_ed_with_line("IGKV3OR2-5", normalised_outlier, fit_table_purity_complete_sig)

#plot_ed_with_line("IGLL1", normalised_outlier, fit_table_purity_complete_sig)


#plot_ed_with_line("IL17A", normalised_outlier, fit_table_purity_complete_sig)


#plot_ed_with_line("IGHV3OR16-16", normalised_outlier, fit_table_purity_complete_sig)


#plot_ed_with_line("IGHV3OR16-16", normalised_outlier, fit_table_purity_complete_sig)


#plot_ed_with_line("NPFFR1", normalised_outlier, fit_table_purity_complete_sig)

p2<-plot_ed_with_line("ABCA13", normalised_outlier, run_3_fit) + labs(subtitle = "Early Decrease") #Could get better curve

#p1<-plot_ed_with_line("SPOCK2", normalised_outlier, run_2_fit) mIDDLE INCREASE

p3<-plot_ed_with_line("NEK2", normalised_outlier, run_2_fit) + labs(subtitle = "Middle Increase")

p4<-plot_ed_with_line("MAFTRR", normalised_outlier, run_2_fit) + labs(subtitle = "Middle Decrease")

#plot_ed_with_line("SPOCK2", normalised_PC_TCGA, fit_table_purity_complete_sig) +labs(subtitle = "Ealry Increase (SPOCK2)")

#p2<-plot_ed_with_line("NEK2", normalised_PC_TCGA, fit_table_purity_complete_sig) 

#p3<-plot_ed_with_line("MAFTRR", normalised_PC_TCGA, fit_table_purity_complete_sig) 

#p4<- plot_ed_with_line("CCDC178", normalised_outlier, run_2_fit)

p5<-plot_ed_with_line("UBE2E3", normalised_outlier, fit_table_purity_complete_sig) +labs(subtitle="Late Increase")

p6<-plot_ed_with_line("AJAP1", normalised_outlier, run_3_fit) + labs(subtitle="Late Decrease")
#Add Examples to choose 
#Early increase / decrease
#Middle Increase /decrease
#Late Increase /decrease

grid.arrange(grobs = list(p1, p2, p3, p4, p5, p6), ncol=2, top="Fig 3. Examples of Sigmodial Trends Detected (Localised inflection)", bottom ="Each point represents a recorded result from a different sample. The black line is the curve fitted by the model.")

```

## Examples of Genes with Wide Inflections (i.e. Linear-like Trend) *(Inflection sd >0.9749, in the fourth quartile)*
```{r, echo=FALSE}

#Plot normalised read conts on log scale, against scale CAPRA_S
#Overlay TABI sigmoid equation (using mean values for each parameter value in the equation)
#Details of plotting function in appendix
p1<-plot_ed_with_line("ACPP", normalised_outlier, run_2_fit)

p2<-plot_ed_with_line("SPATA5L1", normalised_outlier, run_2_fit)

p3<-plot_ed_with_line("ABHD1", normalised_outlier, run_3_fit)

#p3<-plot_ed_with_line("JRKL", normalised_outlier, run_2_fit)

p4<-plot_ed_with_line("ABHD17B", normalised_outlier, run_2_fit)

grid.arrange(grobs = list(p1, p2, p3, p4), ncol=2, top="Fig 4. Examples of Linear Trends Detected (Wide inflection)", bottom ="Each point represents a recorded result from a different sample. The overlayed black line is the curve fitted by the model.")

```
## Examples of trends initially caused by outliers 

***To add comment when second passage has finished running

```{r, echo=FALSE}
#Plot normalised read conts on log scale, against scale CAPRA_S
#Overlay TABI sigmoid equation (using mean values for each parameter value in the equation)
#Details of plotting function in appendix


p1<-plot_ed_with_line("HOXA1", normalised_PC_TCGA, fit_table_purity_complete)

p2<-plot_ed_with_line("HOXA1", normalised_outlier, run_2_fit)

p3<-plot_ed_with_line("MIR210HG", normalised_PC_TCGA, fit_table_purity_complete) #Still problem even with outlier removal

p4<-plot_ed_with_line("MIR210HG", normalised_outlier, run_2_fit)

p5<-plot_ed_with_line("RBM44", normalised_PC_TCGA, fit_table_purity_complete)

p6<-plot_ed_with_line("RBM44", normalised_outlier, run_2_fit)

#plot_ed_with_line("SLC24A1", normalised_outlier, run_2_fit) #Still Problem with equation 

#plot_ed_with_line("HNRNPA1P54", normalised_outlier, run_2_fit)

grid.arrange(grobs = list(p1, p2, p3, p4), ncol=2, top="Fig 5. Examples of Trends Before (Left) and After (Right) Outlier Removal", bottom ="Each point represents a recorded result from a different sample. The overlayed black line is the curve fitted by the model.")
```

# (6) Biological Results and Interpretation:
Of of all statistically significant genes, those with localised inflections (calculated inflection standard deviations <0.7375) were taken, and two futher groups were created; genes with early changes (defined as calculated inflection mean < 0) and genes with late changes (defined as calculated inflection mean >0). Two different overrepresentation test were then undertaken (PANTHER Overrepresentation Test using GO Ontology database Released 2020-01-03, From: http://geneontology.org/ and Computed overlap with Molecular Signatures Database (MSigDB)* From: https://www.gsea-msigdb.org/gsea/msigdb/index.jsp) and the functional gene groups which were significantly overrepresentated in these two groups were collected (see tables in appendix).

Of all declared statistically significant overlap between genes with localised early changes and genes sets noticeable is the recurrent instance of larger than expected numbers of genes from gene sets involved with **cell cycle and division** (*e.g mitotic spindle assembly, sister chromatid segregation, organelle fission, cell cycle gene groups etc.*) as well as those involved in **immunological processes** (*phagocytosis, response to bacterium, B cell receptor signalling pathway, complement activation etc.*). 

```{r,echo=FALSE}

table_1<-(read.csv("overlap_early_pantha.csv")  %>% 
   as_tibble %>%  
   rename("Gene Function Set"= "ï..GO.biological.process.complete",
                                                                "Total Number Genes Set"="Homo.sapiens...REFLIST..20996.",
                                                                "Number of Overlap"="upload_1..203.",
                                                                "Expected Number to overlap" = "upload_1..expected.",
                                                                "Fewer or Greater Than Expected"= "upload_1..over.under.",
                                                                "Fold Enrichment" = "upload_1..fold.Enrichment.",
                                                                "Raw P-value" = "upload_1..raw.P.value.",
                                                                "FDR" = "upload_1..FDR.")) %>% arrange(`Raw P-value`)


table_test<-table_1 %>% filter(grepl("phagocytosis, recognition", `Gene Function Set`)|
                   grepl("mitotic spindle assembly",`Gene Function Set`)|
                     grepl("mitotic sister chromatid segregation", `Gene Function Set`)|
                     grepl("B cell receptor signaling pathway", `Gene Function Set`) )

knitr::kable(table_test, "latex", longtable = TRUE, booktabs=T, row.names=F, caption = "Significant reulsts (P-value <0.05) from PANTHER Overrepresentation Test using GO Ontology database Released 2020-01-03 (Genes with early changes) - Top 4 Broad Categories", digits = 20) %>% 
  kable_styling(latex_options = c("striped","hold_position", "repeat_header"), full_width=F, font_size=10, position = "center") %>%
  row_spec(0, bold=T) %>%
  column_spec(1, width = "10em", bold=T, border_left = F) %>%
  column_spec(2, width = "5em") %>%
  column_spec(3, width = "5em") %>%
  column_spec(4, width = "5em") %>%
  column_spec(5, width = "3em") %>%
  column_spec(6, width = "3em") %>%
  column_spec(8, width = "5em", border_right = F) 

```

In comparison, genes with localised late changes were recurrently significantly associated with overlap in genes sets involved in **cellular, muscular and neural development and contraction** (*muscle filament sliding, sarcomere organization, actomyosin structure organization, neurotransmitter transport, neuron differentiation, neurogenesis, long-term synaptic potentiation etc.*).  

```{r,echo=FALSE}

table_2<-(read.csv("overlap_late_pantha.csv") %>% 
   as_tibble() %>% 
   rename("Gene Function Set"= "ï..GO.biological.process.complete",
                                                                "Total Number Genes Set"="Homo.sapiens...REFLIST..20996.",
                                                                "Number of Overlap"="upload_1..522.",
                                                                "Expected Number to overlap" = "upload_1..expected.",
                                                                "Fewer or Greater Than Expected"= "upload_1..over.under.",
                                                                "Fold Enrichment" = "upload_1..fold.Enrichment.",
                                                                "Raw P-value" = "upload_1..raw.P.value.",
                                                                "FDR" = "upload_1..FDR.")) %>% arrange(`Raw P-value`)
table_testing<- table_2 %>%
  filter(grepl("skeletal muscle thin filament assembly", `Gene Function Set`)|
           grepl("muscle filament sliding", `Gene Function Set`)|
           grepl("cardiac myofibril assembly", `Gene Function Set`)|
           grepl("chemical synaptic transmission", `Gene Function Set`))

knitr::kable(table_testing, "latex", longtable = TRUE, booktabs=T, row.names=F, caption = "Significant Results (P-value <0.05) from PANTHER Overrepresentation Test using GO Ontology database Released 2020-01-03 (Genes with late changes) - Top 4 Broad Categories", digits = 20) %>% 
  kable_styling(latex_options = c("striped","hold_position", "repeat_header"), full_width=F, font_size=10, position = "center") %>%
  row_spec(0, bold=T) %>%
  column_spec(1, width = "10em", bold=T, border_left = F) %>%
  column_spec(2, width = "5em") %>%
  column_spec(3, width = "5em") %>%
  column_spec(4, width = "5em") %>%
  column_spec(5, width = "3em") %>%
  column_spec(6, width = "3em") %>%
  column_spec(8, width = "5em", border_right = F) 

```

When this analysis was reapplied using Molecular Signatures Database (MSigDB, with collections C1, C3, C4, C5, C6, C7, H) a similar trend of gene set overlap was found, now with localised early changes also showing associations with genes sets of hallmark changes found in other cancers (such as lung and breast) and late changes showed association between known genes sets of hallmarks of prostate cancer. 

# (7) Appendix: 

### Tables from overrepresentation tests 

```{r over_rep tables, echo=FALSE}


knitr::kable(table_1, "latex", longtable = TRUE, booktabs=T, row.names=F, caption = "Significant reulsts (P-value <0.05)from PANTHER Overrepresentation Test using GO Ontology database Released 2020-01-03 (Genes with early changes) - Sorted by P-value", digits = 20) %>% 
  kable_styling(latex_options = c("striped","hold_position", "repeat_header"), full_width=F, font_size=10, position = "center") %>%
  row_spec(0, bold=T) %>%
  column_spec(1, width = "10em", bold=T, border_left = F) %>%
  column_spec(2, width = "5em") %>%
  column_spec(3, width = "5em") %>%
  column_spec(4, width = "5em") %>%
  column_spec(5, width = "3em") %>%
  column_spec(6, width = "3em") %>%
  column_spec(8, width = "5em", border_right = F) 



table_2<-(read.csv("overlap_late_pantha.csv") %>% 
   as_tibble() %>% 
   rename("Gene Function Set"= "ï..GO.biological.process.complete",
                                                                "Total Number Genes Set"="Homo.sapiens...REFLIST..20996.",
                                                                "Number of Overlap"="upload_1..522.",
                                                                "Expected Number to overlap" = "upload_1..expected.",
                                                                "Fewer or Greater Than Expected"= "upload_1..over.under.",
                                                                "Fold Enrichment" = "upload_1..fold.Enrichment.",
                                                                "Raw P-value" = "upload_1..raw.P.value.",
                                                                "FDR" = "upload_1..FDR.")) %>% arrange(`Raw P-value`)
knitr::kable(table_2, "latex", longtable = TRUE, booktabs=T, row.names=F, caption = "Significant Results (P-value <0.05) from PANTHER Overrepresentation Test using GO Ontology database Released 2020-01-03 (Genes with late changes) - sorted by P-value", digits = 20) %>% 
  kable_styling(latex_options = c("striped","hold_position", "repeat_header"), full_width=F, font_size=10, position = "center") %>%
  row_spec(0, bold=T) %>%
  column_spec(1, width = "10em", bold=T, border_left = F) %>%
  column_spec(2, width = "5em") %>%
  column_spec(3, width = "5em") %>%
  column_spec(4, width = "5em") %>%
  column_spec(5, width = "3em") %>%
  column_spec(6, width = "3em") %>%
  column_spec(8, width = "5em", border_right = F) 

early_overlap_non_pantha<-read.csv("~/Overlap_Early_Non_Pantha.csv") %>% 
  as_tibble()
table_3<-(early_overlap_non_pantha %>% 
    select(-"Description") %>%
    rename("Functional Gene set" = "ï..Gene.Set.Name", 
           "Total Genes In Gene Set" = X..Genes.in.Gene.Set..K.,
           "Genes In Overlap" = X..Genes.in.Overlap..k.,
           "Expected Number to Overlap" = k.K,
           "P-value" = p.value,
           "FDR q value" = FDR.q.value)) %>%
  arrange(`P-value`)

table_3$`Functional Gene set`<-gsub("_", " ", table_3$`Functional Gene set`)

knitr::kable(table_3, "latex", longtable = TRUE, booktabs=T, row.names=F, caption= "Computing overlap with Molecular Signatures Database (MSigDB) Early Changes", digits = 25) %>% 
  kable_styling(latex_options = c("striped","hold_position", "repeat_header"), full_width=F, font_size=10, position = "center") %>%
  row_spec(0, bold=T) %>%
  column_spec(1, width = "15em", bold=T, border_left = F) %>%
  column_spec(2, width = "5em", bold=F, border_left = F) %>%
  column_spec(3, width = "5em", bold=F, border_left = F) %>%
  column_spec(4, width = "5em", bold=F, border_left = F)
#Problem as _ arent compressed in latex cuasing large table columns size 


late_overlap_non_pantha<-read.csv("~/Overlap_Late_Non.csv") %>% 
  as_tibble()
table_4<-(late_overlap_non_pantha %>% 
    select(-"Description") %>%
    rename("Functional Gene set" = "ï..Gene.Set.Name", 
           "Total Genes In Gene Set" = X..Genes.in.Gene.Set..K.,
           "Genes In Overlap" = X..Genes.in.Overlap..k.,
           "Expected Number to Overlap" = k.K,
              "P-value" = p.value,
           "FDR q value" = FDR.q.value)) %>%
  arrange(`P-value`)

table_4$`Functional Gene set`<-gsub("_", " ", table_4$`Functional Gene set`)

knitr::kable(table_4, "latex", longtable = TRUE, booktabs=T, row.names=F, caption= "Computing overlap with Molecular Signatures Database (MSigDB) Late Changes", digits = 25) %>% 
  kable_styling(latex_options = c("striped","hold_position", "repeat_header"), full_width=F, font_size=10, position = "center") %>%
  row_spec(0, bold=T) %>%
  column_spec(1, width = "15em", bold=T, border_left = F) %>%
  column_spec(2, width = "5em", bold=F, border_left = F) %>%
  column_spec(3, width = "5em", bold=F, border_left = F) %>%
  column_spec(4, width = "5em", bold=F, border_left = F)

```